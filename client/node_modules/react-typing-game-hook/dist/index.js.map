{"version":3,"file":"index.js","sources":["../src/Actions/reset.ts","../src/Actions/index.ts","../src/types.ts","../src/index.ts","../src/Actions/setCurrentIndex.ts","../src/Actions/end.ts","../src/Actions/typingInsert.ts","../src/Actions/typingDelete.ts"],"sourcesContent":["import type { TypingStateType } from '../types';\r\n\r\nexport default (state: TypingStateType): TypingStateType => {\r\n  let { chars } = state;\r\n\r\n  return {\r\n    ...state,\r\n    startTime: null,\r\n    endTime: null,\r\n    charsState: new Array(chars.length).fill(0),\r\n    currIndex: -1,\r\n    currChar: '',\r\n    correctChar: 0,\r\n    errorChar: 0,\r\n    phase: 0,\r\n  };\r\n};\r\n","import type { TypingStateType } from '../types';\r\n\r\nexport enum ActionType {\r\n  _ONTEXTCHANGE = 'INTERNAL/ONTEXTCHANGE',\r\n  RESET = 'RESET',\r\n  END = 'END',\r\n  TYPINGINSERT = 'TYPING/INSERT',\r\n  TYPINGDELETE = 'TYPING/DELETE',\r\n  SETCURRENTINDEX = 'SET/CURRENTINDEX',\r\n}\r\n\r\nexport type ActionItemType =\r\n  | { type: ActionType.RESET; payload?: undefined }\r\n  | { type: ActionType.END; payload?: undefined }\r\n  | { type: ActionType.TYPINGDELETE; payload: boolean }\r\n  | { type: ActionType.TYPINGINSERT; payload: string | null }\r\n  | { type: ActionType.SETCURRENTINDEX; payload: number }\r\n  | {type: ActionType._ONTEXTCHANGE; payload: TypingStateType}\r\n\r\nexport { default as RESET } from './reset';\r\nexport { default as SETCURRENTINDEX } from './setCurrentIndex';\r\nexport { default as END } from './end';\r\nexport { default as TYPINGINSERT } from './typingInsert';\r\nexport { default as TYPINGDELETE } from './typingDelete';\r\n","type countErrorTypes = 'everytime' | 'once';\r\n\r\n/**\r\n * Constants for different phases.\r\n * @enum {number}\r\n */\r\nexport enum PhaseType {\r\n  /**\r\n   * Phase when typing has yet to start.\r\n   */\r\n  NotStarted = 0,\r\n  /**\r\n   * Phase when typing has started.\r\n   */\r\n  Started = 1,\r\n  /**\r\n   * Phase when typing has ended.\r\n   */\r\n  Ended = 2,\r\n}\r\n\r\n/**\r\n * Constants for different character states.\r\n * @enum {number}\r\n */\r\nexport enum CharStateType {\r\n  /**\r\n   * Character has yet to be determined to be correct or incorrect.\r\n   */\r\n  Incomplete = 0,\r\n  /**\r\n   * Character is determined to be correct.\r\n   */\r\n  Correct = 1,\r\n  /**\r\n   * Character is determined to be incorrect.\r\n   */\r\n  Incorrect = 2,\r\n}\r\n\r\nexport interface TypingOptionsType {\r\n  /**\r\n   * Move on to the next word when space is inputted, defaults to `true`.\r\n   */\r\n  skipCurrentWordOnSpace: boolean;\r\n  /**\r\n   * Stay on the current index when the inputted character is wrong, defaults to `false`.\r\n   */\r\n  pauseOnError: boolean;\r\n  /**\r\n   * With `everytime`, choose to count errors everytime a mistake is made.\r\n   * With `once`, choose to count errors only once for each mistake made.\r\n   */\r\n  countErrors: countErrorTypes;\r\n}\r\n\r\n/**\r\n * Properties of the typing game hook.\r\n */\r\nexport interface TypingStateType extends TypingOptionsType {\r\n  /**\r\n   * The inputted string to be used.\r\n   */\r\n  chars: string;\r\n  /**\r\n   * Array of each character's state in the string.\r\n   * Each item in the array represents the state of each character in the string.\r\n   * `0` represents incomplete, `1` represents correct and, `2` represents incorrect.\r\n   */\r\n  charsState: CharStateType[];\r\n  /**\r\n   * Length of the string used.\r\n   */\r\n  length: number;\r\n  /**\r\n   * Current index of the character the user have typed till.\r\n   */\r\n  currIndex: number;\r\n  /**\r\n   * Current character the user have typed till.\r\n   */\r\n  currChar: string;\r\n  /**\r\n   * Number of correct character the user had typed.\r\n   */\r\n  correctChar: number;\r\n  /**\r\n   * Number of incorrect character the user had typed.\r\n   */\r\n  errorChar: number;\r\n  /**\r\n   * Represent the current state.\r\n   * `0` typing haven't started, `1` typing started, `2` typing ended.\r\n   */\r\n  phase: PhaseType;\r\n  /**\r\n   * Time in milliseconds when the typing started.\r\n   */\r\n  startTime: number | null;\r\n  /**\r\n   * Time in milliseconds when the typing ended.\r\n   */\r\n  endTime: number | null;\r\n}\r\n\r\n/**\r\n * Methods of the typing game hook.\r\n */\r\nexport interface TypingActionType {\r\n  /**\r\n   * Duration in milliseconds since the typing started.\r\n   * 0 if the typing has yet to start.\r\n   * When the typing ended, the duration will be equivalent to endTime - startTime.\r\n   */\r\n  getDuration: () => number;\r\n  /**\r\n   * Reset the typing sequence.\r\n   */\r\n  resetTyping: () => void;\r\n  /**\r\n   * Ends the typing sequence but not reset it.\r\n   */\r\n  endTyping: () => void;\r\n  /**\r\n   * Insert a character into the current typing sequence.\r\n   * @param {string | null} char A character to be inserted.\r\n   * If falsy or no argument is supplied, skip the current character.\r\n   */\r\n  insertTyping: (char?: string) => void;\r\n  /**\r\n   * Delete a character from the current typing sequence.\r\n   * @param {boolean} [deleteWord] If `true`, deletes the whole of the current word. Defaults to `false`.\r\n   */\r\n  deleteTyping: (deleteWord?: boolean) => void;\r\n  /**\r\n   * Set the current index manually.\r\n   * @param {number} num Allows from -1 to length - 1 of the text, numbers that falls outside of the range will return a false.\r\n   */\r\n  setCurrIndex: (num: number) => boolean;\r\n}\r\n","import { Reducer, useCallback, useEffect, useMemo, useReducer } from 'react';\r\nimport {\r\n  RESET,\r\n  SETCURRENTINDEX,\r\n  END,\r\n  TYPINGINSERT,\r\n  TYPINGDELETE,\r\n  ActionType,\r\n  ActionItemType,\r\n} from './Actions';\r\n\r\nimport {\r\n  CharStateType,\r\n  PhaseType,\r\n  TypingActionType,\r\n  TypingOptionsType,\r\n  TypingStateType,\r\n} from './types';\r\n\r\nconst reducer: Reducer<TypingStateType, ActionItemType> = (state, action) => {\r\n  switch (action.type) {\r\n    case ActionType.SETCURRENTINDEX:\r\n      return SETCURRENTINDEX(state, action);\r\n    case ActionType.RESET:\r\n      return RESET(state);\r\n    case ActionType.END:\r\n      return END(state);\r\n    case ActionType.TYPINGINSERT:\r\n      return TYPINGINSERT(state, action);\r\n    case ActionType.TYPINGDELETE:\r\n      return TYPINGDELETE(state, action);\r\n    case ActionType._ONTEXTCHANGE:\r\n      return action.payload;\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * React hook to create typing challenge/game/practice/test.\r\n * @param {string} text A string of words to be used for the typing sequence.\r\n * @param {Object} [options] Addition options to customize the functionality of the typing sequence.\r\n * @param {boolean} [options.skipCurrentWordOnSpace] Move on to the next word when space is inputted, defaults to `true`.\r\n * @param {boolean} [options.pauseOnError] Stay on the current index when the inputted character is wrong, defaults to `false`.\r\n * @param {countErrorTypes} [options.countErrors]\r\n * @returns Returns the state and the actions available for the typing hook.\r\n */\r\nconst useTypingGame = (\r\n  text: string = '',\r\n  options: Partial<TypingOptionsType> = {}\r\n): { states: TypingStateType; actions: TypingActionType } => {\r\n  const initialState = useMemo<TypingStateType>(\r\n    () => ({\r\n      startTime: null,\r\n      endTime: null,\r\n      chars: text,\r\n      charsState: new Array(text.length).fill(0),\r\n      length: text.length,\r\n      currIndex: -1,\r\n      currChar: '',\r\n      correctChar: 0,\r\n      errorChar: 0,\r\n      phase: 0,\r\n      skipCurrentWordOnSpace: true,\r\n      pauseOnError: false,\r\n      countErrors: 'everytime',\r\n      ...options,\r\n    }),\r\n    [options, text]\r\n  );\r\n\r\n  const [states, dispatch] = useReducer<\r\n    Reducer<TypingStateType, ActionItemType>\r\n  >(reducer, initialState);\r\n\r\n  useEffect(() => {\r\n    dispatch({\r\n      type: ActionType._ONTEXTCHANGE,\r\n      payload: initialState,\r\n    });\r\n  }, [text, dispatch]);\r\n\r\n  const getDuration = useCallback<TypingActionType['getDuration']>(() => {\r\n    switch (states.phase) {\r\n      case PhaseType.NotStarted: {\r\n        return 0;\r\n      }\r\n      case PhaseType.Started: {\r\n        return states.startTime ? new Date().getTime() - states.startTime : 0;\r\n      }\r\n      case PhaseType.Ended: {\r\n        return states.startTime && states.endTime\r\n          ? states.endTime - states.startTime\r\n          : 0;\r\n      }\r\n    }\r\n  }, [states.phase, states.startTime, states.startTime]);\r\n\r\n  const resetTyping = useCallback<TypingActionType['resetTyping']>(\r\n    () => dispatch({ type: ActionType.RESET }),\r\n    [dispatch]\r\n  );\r\n\r\n  const endTyping = useCallback<TypingActionType['endTyping']>(\r\n    () => dispatch({ type: ActionType.END }),\r\n    [dispatch]\r\n  );\r\n\r\n  const insertTyping = useCallback<TypingActionType['insertTyping']>(\r\n    (letter: string | undefined) => {\r\n      const payload = letter ? letter[0] : null;\r\n      dispatch({\r\n        type: ActionType.TYPINGINSERT,\r\n        payload,\r\n      });\r\n    },\r\n    [dispatch]\r\n  );\r\n\r\n  const deleteTyping = useCallback<TypingActionType['deleteTyping']>(\r\n    (deleteWord = false) => {\r\n      dispatch({\r\n        type: ActionType.TYPINGDELETE,\r\n        payload: deleteWord || false,\r\n      });\r\n    },\r\n    [dispatch]\r\n  );\r\n\r\n  const setCurrIndex = useCallback<TypingActionType['setCurrIndex']>(\r\n    (num: number) => {\r\n      if (num < -1 || num >= states.length || states.phase !== 2) {\r\n        return false;\r\n      }\r\n      dispatch({\r\n        type: ActionType.SETCURRENTINDEX,\r\n        payload: num,\r\n      });\r\n      return true;\r\n    },\r\n    [dispatch, states.length, states.phase]\r\n  );\r\n\r\n  return {\r\n    states,\r\n    actions: {\r\n      getDuration,\r\n      resetTyping,\r\n      endTyping,\r\n      insertTyping,\r\n      deleteTyping,\r\n      setCurrIndex,\r\n    },\r\n  };\r\n};\r\n\r\nexport default useTypingGame;\r\n\r\nexport {\r\n  CharStateType,\r\n  PhaseType,\r\n  TypingActionType,\r\n  TypingOptionsType,\r\n  TypingStateType,\r\n};\r\n","import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let { chars, length } = state;\n  let payload = action.payload ?? null;\n  if (\n    payload &&\n    typeof payload === 'number' &&\n    payload >= -1 &&\n    payload < length\n  ) {\n    return { ...state, currIndex: payload, currChar: chars[payload] };\n  } else {\n    return state;\n  }\n};\n","import type { TypingStateType } from '../types';\r\n\r\nexport default (state: TypingStateType): TypingStateType => ({\r\n  ...state,\r\n  phase: 2,\r\n  endTime: new Date().getTime(),\r\n});\r\n","import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    startTime,\n    endTime,\n    chars,\n    charsState,\n    length,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    skipCurrentWordOnSpace,\n    pauseOnError,\n    countErrors,\n  } = state;\n  let letter = action.payload ?? null;\n  let newStartTime = startTime;\n  let newEndTime = endTime;\n  if (phase === 2) {\n    return state;\n  }\n\n  if (phase === 0) {\n    phase = 1;\n    newStartTime = new Date().getTime();\n  }\n\n  let newCharsState = [...charsState];\n  if (\n    letter === ' ' &&\n    chars[currIndex + 1] !== ' ' &&\n    skipCurrentWordOnSpace\n  ) {\n    let newIndex = chars.indexOf(letter, currIndex);\n    currIndex = newIndex === -1 ? length - 1 : newIndex;\n  } else {\n    if (letter !== null) {\n      if (chars[currIndex + 1] !== letter) {\n        if (newCharsState[currIndex + 1] == 2) {\n          if (countErrors === 'everytime') {\n            errorChar += 1;\n          }\n        } else {\n          newCharsState[currIndex + 1] = 2;\n          errorChar += 1;\n        }\n        if (!pauseOnError) {\n          currIndex += 1;\n        }\n      } else {\n        if (\n          newCharsState[currIndex + 1] === 2 &&\n          pauseOnError &&\n          countErrors === 'once'\n        ) {\n          errorChar -= 1;\n        }\n        newCharsState[currIndex + 1] = 1;\n        correctChar += 1;\n        currIndex += 1;\n      }\n    } else {\n      currIndex += 1;\n    }\n  }\n\n  if (currIndex >= length - 1) {\n    newEndTime = new Date().getTime();\n    phase = 2;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    charsState: newCharsState,\n    errorChar,\n    correctChar,\n    currIndex,\n    currChar,\n    phase,\n    startTime: newStartTime,\n    endTime: newEndTime,\n  };\n};\n","import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    chars,\n    charsState,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    countErrors,\n  } = state;\n  let payload = action.payload ?? null;\n\n  if (phase !== 1 || currIndex === -1) {\n    return state;\n  }\n  let newCharsState = [...charsState];\n  if (payload) {\n    let newIndex = chars.lastIndexOf(' ', currIndex);\n    newIndex = newIndex === -1 ? 0 : newIndex + 1;\n    for (let i = currIndex; i >= newIndex; i--) {\n      if (newCharsState[i] === 1) {\n        correctChar -= 1;\n      } else if (newCharsState[i] === 2) {\n        if (countErrors === 'once') {\n          errorChar -= 1;\n        }\n      }\n      newCharsState[i] = 0;\n    }\n    currIndex = newIndex;\n  } else {\n    if (newCharsState[currIndex] === 1) {\n      correctChar -= 1;\n    } else if (newCharsState[currIndex] === 2) {\n      if (countErrors === 'once') {\n        errorChar -= 1;\n      }\n    }\n    newCharsState[currIndex] = 0;\n  }\n  if (currIndex !== -1) {\n    currIndex -= 1;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    currIndex,\n    currChar,\n    charsState: newCharsState,\n    correctChar,\n    errorChar,\n  };\n};\n"],"names":["ActionType","PhaseType","CharStateType","reducer","state","action","type","SETCURRENTINDEX","chars","length","payload","currIndex","currChar","RESET","startTime","endTime","charsState","Array","fill","correctChar","errorChar","phase","END","Date","getTime","TYPINGINSERT","skipCurrentWordOnSpace","pauseOnError","countErrors","letter","newStartTime","newEndTime","newCharsState","newIndex","indexOf","TYPINGDELETE","lastIndexOf","i","_ONTEXTCHANGE","text","options","initialState","useMemo","_a","useReducer","states","dispatch","useEffect","getDuration","useCallback","NotStarted","Started","Ended","resetTyping","endTyping","insertTyping","deleteTyping","deleteWord","setCurrIndex","num","actions"],"mappings":"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"}