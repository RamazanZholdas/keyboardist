{
  "version": 3,
  "sources": ["../../react-typing-game-hook/src/Actions/reset.ts", "../../react-typing-game-hook/src/Actions/index.ts", "../../react-typing-game-hook/src/types.ts", "../../react-typing-game-hook/src/index.ts", "../../react-typing-game-hook/src/Actions/setCurrentIndex.ts", "../../react-typing-game-hook/src/Actions/end.ts", "../../react-typing-game-hook/src/Actions/typingInsert.ts", "../../react-typing-game-hook/src/Actions/typingDelete.ts"],
  "sourcesContent": ["import type { TypingStateType } from '../types';\r\n\r\nexport default (state: TypingStateType): TypingStateType => {\r\n  let { chars } = state;\r\n\r\n  return {\r\n    ...state,\r\n    startTime: null,\r\n    endTime: null,\r\n    charsState: new Array(chars.length).fill(0),\r\n    currIndex: -1,\r\n    currChar: '',\r\n    correctChar: 0,\r\n    errorChar: 0,\r\n    phase: 0,\r\n  };\r\n};\r\n", "import type { TypingStateType } from '../types';\r\n\r\nexport enum ActionType {\r\n  _ONTEXTCHANGE = 'INTERNAL/ONTEXTCHANGE',\r\n  RESET = 'RESET',\r\n  END = 'END',\r\n  TYPINGINSERT = 'TYPING/INSERT',\r\n  TYPINGDELETE = 'TYPING/DELETE',\r\n  SETCURRENTINDEX = 'SET/CURRENTINDEX',\r\n}\r\n\r\nexport type ActionItemType =\r\n  | { type: ActionType.RESET; payload?: undefined }\r\n  | { type: ActionType.END; payload?: undefined }\r\n  | { type: ActionType.TYPINGDELETE; payload: boolean }\r\n  | { type: ActionType.TYPINGINSERT; payload: string | null }\r\n  | { type: ActionType.SETCURRENTINDEX; payload: number }\r\n  | {type: ActionType._ONTEXTCHANGE; payload: TypingStateType}\r\n\r\nexport { default as RESET } from './reset';\r\nexport { default as SETCURRENTINDEX } from './setCurrentIndex';\r\nexport { default as END } from './end';\r\nexport { default as TYPINGINSERT } from './typingInsert';\r\nexport { default as TYPINGDELETE } from './typingDelete';\r\n", "type countErrorTypes = 'everytime' | 'once';\r\n\r\n/**\r\n * Constants for different phases.\r\n * @enum {number}\r\n */\r\nexport enum PhaseType {\r\n  /**\r\n   * Phase when typing has yet to start.\r\n   */\r\n  NotStarted = 0,\r\n  /**\r\n   * Phase when typing has started.\r\n   */\r\n  Started = 1,\r\n  /**\r\n   * Phase when typing has ended.\r\n   */\r\n  Ended = 2,\r\n}\r\n\r\n/**\r\n * Constants for different character states.\r\n * @enum {number}\r\n */\r\nexport enum CharStateType {\r\n  /**\r\n   * Character has yet to be determined to be correct or incorrect.\r\n   */\r\n  Incomplete = 0,\r\n  /**\r\n   * Character is determined to be correct.\r\n   */\r\n  Correct = 1,\r\n  /**\r\n   * Character is determined to be incorrect.\r\n   */\r\n  Incorrect = 2,\r\n}\r\n\r\nexport interface TypingOptionsType {\r\n  /**\r\n   * Move on to the next word when space is inputted, defaults to `true`.\r\n   */\r\n  skipCurrentWordOnSpace: boolean;\r\n  /**\r\n   * Stay on the current index when the inputted character is wrong, defaults to `false`.\r\n   */\r\n  pauseOnError: boolean;\r\n  /**\r\n   * With `everytime`, choose to count errors everytime a mistake is made.\r\n   * With `once`, choose to count errors only once for each mistake made.\r\n   */\r\n  countErrors: countErrorTypes;\r\n}\r\n\r\n/**\r\n * Properties of the typing game hook.\r\n */\r\nexport interface TypingStateType extends TypingOptionsType {\r\n  /**\r\n   * The inputted string to be used.\r\n   */\r\n  chars: string;\r\n  /**\r\n   * Array of each character's state in the string.\r\n   * Each item in the array represents the state of each character in the string.\r\n   * `0` represents incomplete, `1` represents correct and, `2` represents incorrect.\r\n   */\r\n  charsState: CharStateType[];\r\n  /**\r\n   * Length of the string used.\r\n   */\r\n  length: number;\r\n  /**\r\n   * Current index of the character the user have typed till.\r\n   */\r\n  currIndex: number;\r\n  /**\r\n   * Current character the user have typed till.\r\n   */\r\n  currChar: string;\r\n  /**\r\n   * Number of correct character the user had typed.\r\n   */\r\n  correctChar: number;\r\n  /**\r\n   * Number of incorrect character the user had typed.\r\n   */\r\n  errorChar: number;\r\n  /**\r\n   * Represent the current state.\r\n   * `0` typing haven't started, `1` typing started, `2` typing ended.\r\n   */\r\n  phase: PhaseType;\r\n  /**\r\n   * Time in milliseconds when the typing started.\r\n   */\r\n  startTime: number | null;\r\n  /**\r\n   * Time in milliseconds when the typing ended.\r\n   */\r\n  endTime: number | null;\r\n}\r\n\r\n/**\r\n * Methods of the typing game hook.\r\n */\r\nexport interface TypingActionType {\r\n  /**\r\n   * Duration in milliseconds since the typing started.\r\n   * 0 if the typing has yet to start.\r\n   * When the typing ended, the duration will be equivalent to endTime - startTime.\r\n   */\r\n  getDuration: () => number;\r\n  /**\r\n   * Reset the typing sequence.\r\n   */\r\n  resetTyping: () => void;\r\n  /**\r\n   * Ends the typing sequence but not reset it.\r\n   */\r\n  endTyping: () => void;\r\n  /**\r\n   * Insert a character into the current typing sequence.\r\n   * @param {string | null} char A character to be inserted.\r\n   * If falsy or no argument is supplied, skip the current character.\r\n   */\r\n  insertTyping: (char?: string) => void;\r\n  /**\r\n   * Delete a character from the current typing sequence.\r\n   * @param {boolean} [deleteWord] If `true`, deletes the whole of the current word. Defaults to `false`.\r\n   */\r\n  deleteTyping: (deleteWord?: boolean) => void;\r\n  /**\r\n   * Set the current index manually.\r\n   * @param {number} num Allows from -1 to length - 1 of the text, numbers that falls outside of the range will return a false.\r\n   */\r\n  setCurrIndex: (num: number) => boolean;\r\n}\r\n", "import { Reducer, useCallback, useEffect, useMemo, useReducer } from 'react';\r\nimport {\r\n  RESET,\r\n  SETCURRENTINDEX,\r\n  END,\r\n  TYPINGINSERT,\r\n  TYPINGDELETE,\r\n  ActionType,\r\n  ActionItemType,\r\n} from './Actions';\r\n\r\nimport {\r\n  CharStateType,\r\n  PhaseType,\r\n  TypingActionType,\r\n  TypingOptionsType,\r\n  TypingStateType,\r\n} from './types';\r\n\r\nconst reducer: Reducer<TypingStateType, ActionItemType> = (state, action) => {\r\n  switch (action.type) {\r\n    case ActionType.SETCURRENTINDEX:\r\n      return SETCURRENTINDEX(state, action);\r\n    case ActionType.RESET:\r\n      return RESET(state);\r\n    case ActionType.END:\r\n      return END(state);\r\n    case ActionType.TYPINGINSERT:\r\n      return TYPINGINSERT(state, action);\r\n    case ActionType.TYPINGDELETE:\r\n      return TYPINGDELETE(state, action);\r\n    case ActionType._ONTEXTCHANGE:\r\n      return action.payload;\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * React hook to create typing challenge/game/practice/test.\r\n * @param {string} text A string of words to be used for the typing sequence.\r\n * @param {Object} [options] Addition options to customize the functionality of the typing sequence.\r\n * @param {boolean} [options.skipCurrentWordOnSpace] Move on to the next word when space is inputted, defaults to `true`.\r\n * @param {boolean} [options.pauseOnError] Stay on the current index when the inputted character is wrong, defaults to `false`.\r\n * @param {countErrorTypes} [options.countErrors]\r\n * @returns Returns the state and the actions available for the typing hook.\r\n */\r\nconst useTypingGame = (\r\n  text: string = '',\r\n  options: Partial<TypingOptionsType> = {}\r\n): { states: TypingStateType; actions: TypingActionType } => {\r\n  const initialState = useMemo<TypingStateType>(\r\n    () => ({\r\n      startTime: null,\r\n      endTime: null,\r\n      chars: text,\r\n      charsState: new Array(text.length).fill(0),\r\n      length: text.length,\r\n      currIndex: -1,\r\n      currChar: '',\r\n      correctChar: 0,\r\n      errorChar: 0,\r\n      phase: 0,\r\n      skipCurrentWordOnSpace: true,\r\n      pauseOnError: false,\r\n      countErrors: 'everytime',\r\n      ...options,\r\n    }),\r\n    [options, text]\r\n  );\r\n\r\n  const [states, dispatch] = useReducer<\r\n    Reducer<TypingStateType, ActionItemType>\r\n  >(reducer, initialState);\r\n\r\n  useEffect(() => {\r\n    dispatch({\r\n      type: ActionType._ONTEXTCHANGE,\r\n      payload: initialState,\r\n    });\r\n  }, [text, dispatch]);\r\n\r\n  const getDuration = useCallback<TypingActionType['getDuration']>(() => {\r\n    switch (states.phase) {\r\n      case PhaseType.NotStarted: {\r\n        return 0;\r\n      }\r\n      case PhaseType.Started: {\r\n        return states.startTime ? new Date().getTime() - states.startTime : 0;\r\n      }\r\n      case PhaseType.Ended: {\r\n        return states.startTime && states.endTime\r\n          ? states.endTime - states.startTime\r\n          : 0;\r\n      }\r\n    }\r\n  }, [states.phase, states.startTime, states.startTime]);\r\n\r\n  const resetTyping = useCallback<TypingActionType['resetTyping']>(\r\n    () => dispatch({ type: ActionType.RESET }),\r\n    [dispatch]\r\n  );\r\n\r\n  const endTyping = useCallback<TypingActionType['endTyping']>(\r\n    () => dispatch({ type: ActionType.END }),\r\n    [dispatch]\r\n  );\r\n\r\n  const insertTyping = useCallback<TypingActionType['insertTyping']>(\r\n    (letter: string | undefined) => {\r\n      const payload = letter ? letter[0] : null;\r\n      dispatch({\r\n        type: ActionType.TYPINGINSERT,\r\n        payload,\r\n      });\r\n    },\r\n    [dispatch]\r\n  );\r\n\r\n  const deleteTyping = useCallback<TypingActionType['deleteTyping']>(\r\n    (deleteWord = false) => {\r\n      dispatch({\r\n        type: ActionType.TYPINGDELETE,\r\n        payload: deleteWord || false,\r\n      });\r\n    },\r\n    [dispatch]\r\n  );\r\n\r\n  const setCurrIndex = useCallback<TypingActionType['setCurrIndex']>(\r\n    (num: number) => {\r\n      if (num < -1 || num >= states.length || states.phase !== 2) {\r\n        return false;\r\n      }\r\n      dispatch({\r\n        type: ActionType.SETCURRENTINDEX,\r\n        payload: num,\r\n      });\r\n      return true;\r\n    },\r\n    [dispatch, states.length, states.phase]\r\n  );\r\n\r\n  return {\r\n    states,\r\n    actions: {\r\n      getDuration,\r\n      resetTyping,\r\n      endTyping,\r\n      insertTyping,\r\n      deleteTyping,\r\n      setCurrIndex,\r\n    },\r\n  };\r\n};\r\n\r\nexport default useTypingGame;\r\n\r\nexport {\r\n  CharStateType,\r\n  PhaseType,\r\n  TypingActionType,\r\n  TypingOptionsType,\r\n  TypingStateType,\r\n};\r\n", "import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let { chars, length } = state;\n  let payload = action.payload ?? null;\n  if (\n    payload &&\n    typeof payload === 'number' &&\n    payload >= -1 &&\n    payload < length\n  ) {\n    return { ...state, currIndex: payload, currChar: chars[payload] };\n  } else {\n    return state;\n  }\n};\n", "import type { TypingStateType } from '../types';\r\n\r\nexport default (state: TypingStateType): TypingStateType => ({\r\n  ...state,\r\n  phase: 2,\r\n  endTime: new Date().getTime(),\r\n});\r\n", "import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    startTime,\n    endTime,\n    chars,\n    charsState,\n    length,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    skipCurrentWordOnSpace,\n    pauseOnError,\n    countErrors,\n  } = state;\n  let letter = action.payload ?? null;\n  let newStartTime = startTime;\n  let newEndTime = endTime;\n  if (phase === 2) {\n    return state;\n  }\n\n  if (phase === 0) {\n    phase = 1;\n    newStartTime = new Date().getTime();\n  }\n\n  let newCharsState = [...charsState];\n  if (\n    letter === ' ' &&\n    chars[currIndex + 1] !== ' ' &&\n    skipCurrentWordOnSpace\n  ) {\n    let newIndex = chars.indexOf(letter, currIndex);\n    currIndex = newIndex === -1 ? length - 1 : newIndex;\n  } else {\n    if (letter !== null) {\n      if (chars[currIndex + 1] !== letter) {\n        if (newCharsState[currIndex + 1] == 2) {\n          if (countErrors === 'everytime') {\n            errorChar += 1;\n          }\n        } else {\n          newCharsState[currIndex + 1] = 2;\n          errorChar += 1;\n        }\n        if (!pauseOnError) {\n          currIndex += 1;\n        }\n      } else {\n        if (\n          newCharsState[currIndex + 1] === 2 &&\n          pauseOnError &&\n          countErrors === 'once'\n        ) {\n          errorChar -= 1;\n        }\n        newCharsState[currIndex + 1] = 1;\n        correctChar += 1;\n        currIndex += 1;\n      }\n    } else {\n      currIndex += 1;\n    }\n  }\n\n  if (currIndex >= length - 1) {\n    newEndTime = new Date().getTime();\n    phase = 2;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    charsState: newCharsState,\n    errorChar,\n    correctChar,\n    currIndex,\n    currChar,\n    phase,\n    startTime: newStartTime,\n    endTime: newEndTime,\n  };\n};\n", "import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    chars,\n    charsState,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    countErrors,\n  } = state;\n  let payload = action.payload ?? null;\n\n  if (phase !== 1 || currIndex === -1) {\n    return state;\n  }\n  let newCharsState = [...charsState];\n  if (payload) {\n    let newIndex = chars.lastIndexOf(' ', currIndex);\n    newIndex = newIndex === -1 ? 0 : newIndex + 1;\n    for (let i = currIndex; i >= newIndex; i--) {\n      if (newCharsState[i] === 1) {\n        correctChar -= 1;\n      } else if (newCharsState[i] === 2) {\n        if (countErrors === 'once') {\n          errorChar -= 1;\n        }\n      }\n      newCharsState[i] = 0;\n    }\n    currIndex = newIndex;\n  } else {\n    if (newCharsState[currIndex] === 1) {\n      correctChar -= 1;\n    } else if (newCharsState[currIndex] === 2) {\n      if (countErrors === 'once') {\n        errorChar -= 1;\n      }\n    }\n    newCharsState[currIndex] = 0;\n  }\n  if (currIndex !== -1) {\n    currIndex -= 1;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    currIndex,\n    currChar,\n    charsState: newCharsState,\n    correctChar,\n    errorChar,\n  };\n};\n"],
  "mappings": "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",
  "names": ["ActionType", "PhaseType", "CharStateType", "reducer", "state", "action", "type", "SETCURRENTINDEX", "chars", "length", "payload", "currIndex", "currChar", "RESET", "startTime", "endTime", "charsState", "Array", "fill", "correctChar", "errorChar", "phase", "END", "Date", "getTime", "TYPINGINSERT", "skipCurrentWordOnSpace", "pauseOnError", "countErrors", "letter", "newStartTime", "newEndTime", "newCharsState", "newIndex", "indexOf", "TYPINGDELETE", "lastIndexOf", "i", "_ONTEXTCHANGE", "text", "options", "initialState", "useMemo", "_a", "useReducer", "states", "dispatch", "useEffect", "getDuration", "useCallback", "NotStarted", "Started", "Ended", "resetTyping", "endTyping", "insertTyping", "deleteTyping", "deleteWord", "setCurrIndex", "num", "actions"]
}
